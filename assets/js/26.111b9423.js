(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{379:function(e,t,a){"use strict";a.r(t);var i=a(42),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"specification-ipld-data-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification-ipld-data-model"}},[e._v("#")]),e._v(" Specification: IPLD Data Model")]),e._v(" "),a("p",[a("strong",[e._v("Status: Descriptive - Draft")])]),e._v(" "),a("p",[e._v("The IPLD Data Model is a core part of the IPLD specification,\nwhich describes what data is representable in IPLD --\nfor example, booleans, integers, textual strings, maps and lists, etc.")]),e._v(" "),a("p",[e._v("While the Data Model describes these representations in the abstract,\n"),a("a",{attrs:{href:"Codecs"}},[e._v("Codecs")]),e._v(" specify exactly how these data are transcribed into serialized bytes.\n(Another component of the IPLD specifications, "),a("a",{attrs:{href:"../schemas"}},[e._v("Schemas")]),e._v(", provide\nadditional optional tooling on top of the Data Model which can further refine,\ndescribe, and constrain the range of acceptable data values.)")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("There is not "),a("strong",[e._v("one")]),e._v(" block format but "),a("strong",[e._v("many")]),e._v(" block formats widely used today in content\naddressed data structures. We assume that we'll see more of these block formats in the\nfuture and not less. It is quite clear then that a reasonable and more future proof approach\nto using these data structures is to be block format agnostic.")]),e._v(" "),a("p",[e._v("The data model defines a common respresentation of basic types that "),a("strong",[e._v("are easily representable\nby common programming languages.")]),e._v(' This provides the foundation for block format agnostic tools\nto be built using familiar native types in a programmer\'s preferred language. As such, there\nis an element of "lowest common denominator" to the IPLD Data Model in that it cannot support\nsome advanced features (like non-string keys for Maps) because support for such a feature\nis not common enough among programming languages.')]),e._v(" "),a("p",[e._v("This does not mean that a block format could not support more advanced features than exist in the\ndata model, it just means that the common set of tools IPLD is building w/ its block format\nagnostic approach cannot be easily leveraged to use those features.")]),e._v(" "),a("h2",{attrs:{id:"kinds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kinds"}},[e._v("#")]),e._v(" Kinds")]),e._v(" "),a("p",[e._v("The following is the list of essential "),a("em",[e._v("kinds")]),e._v(" (or more formally, "),a("em",[e._v("representation kinds")]),e._v(")\nof data representable in the IPLD Data Model:")]),e._v(" "),a("ul",[a("li",[e._v("Null")]),e._v(" "),a("li",[e._v("Boolean")]),e._v(" "),a("li",[e._v("Integer")]),e._v(" "),a("li",[e._v("Float")]),e._v(" "),a("li",[e._v("String")]),e._v(" "),a("li",[e._v("Bytes")]),e._v(" "),a("li",[e._v("List")]),e._v(" "),a("li",[e._v("Map")]),e._v(" "),a("li",[e._v("Link")])]),e._v(" "),a("p",[e._v('(Note that we use the term "'),a("em",[e._v("kinds")]),e._v('" here to disambiguate this from "'),a("em",[e._v("types")]),e._v("\",\nwhich is a term we'll use at the "),a("a",{attrs:{href:"../schemas"}},[e._v("Schemas")]),e._v(" level.)")]),e._v(" "),a("p",[e._v("The "),a("em",[e._v("recursive kinds")]),e._v(" are:")]),e._v(" "),a("ul",[a("li",[e._v("List")]),e._v(" "),a("li",[e._v("Map")])]),e._v(" "),a("p",[e._v("The "),a("em",[e._v("scalar kinds")]),e._v(" (the complement of recursive) are:")]),e._v(" "),a("ul",[a("li",[e._v("Null")]),e._v(" "),a("li",[e._v("Boolean")]),e._v(" "),a("li",[e._v("Integer")]),e._v(" "),a("li",[e._v("Float")]),e._v(" "),a("li",[e._v("String")]),e._v(" "),a("li",[e._v("Bytes")]),e._v(" "),a("li",[e._v("Link")])]),e._v(" "),a("p",[e._v("(Note that "),a("a",{attrs:{href:"../schemas"}},[e._v("Schemas")]),e._v(' introduce a few more kinds -- when clarification is necessary,\nthese Data Model kinds can be called the "'),a("em",[e._v("representation kinds")]),e._v('",\nwhile the additional kinds introduced in the Schema layer are "'),a("em",[e._v("perceived kinds")]),e._v('".)')]),e._v(" "),a("h3",{attrs:{id:"kinds-reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kinds-reference"}},[e._v("#")]),e._v(" Kinds Reference")]),e._v(" "),a("p",[e._v("Each of the following sections provides details about each of the kinds\nintroduced in the summary table above.")]),e._v(" "),a("h4",{attrs:{id:"null-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#null-kind"}},[e._v("#")]),e._v(" Null kind")]),e._v(" "),a("p",[e._v("Null is a scalar kind.  Its cardinality is one -- the only value is 'null'.")]),e._v(" "),a("h4",{attrs:{id:"boolean-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#boolean-kind"}},[e._v("#")]),e._v(" Boolean kind")]),e._v(" "),a("p",[e._v("Boolean is a scalar kind.  Its cardinality is two -- either the value 'true' or the value 'false'.")]),e._v(" "),a("h4",{attrs:{id:"integer-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#integer-kind"}},[e._v("#")]),e._v(" Integer kind")]),e._v(" "),a("h4",{attrs:{id:"float-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#float-kind"}},[e._v("#")]),e._v(" Float kind")]),e._v(" "),a("h4",{attrs:{id:"string-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-kind"}},[e._v("#")]),e._v(" String kind")]),e._v(" "),a("p",[e._v("String is a scalar kind.  Its cardinality is infinite -- strings do not have a length limit.")]),e._v(" "),a("p",[e._v("Strings should be UTF-8 text, in "),a("a",{attrs:{href:"https://www.unicode.org/reports/tr15/#Norm_Forms",target:"_blank",rel:"noopener noreferrer"}},[e._v("NFC"),a("OutboundLink")],1),e._v(" canonicalization.")]),e._v(" "),a("h4",{attrs:{id:"bytes-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytes-kind"}},[e._v("#")]),e._v(" Bytes kind")]),e._v(" "),a("p",[e._v("Bytes is a scalar kind.  Its cardinality is infinite -- byte sequences do not have a length limit.")]),e._v(" "),a("p",[e._v("Bytes are distinct from strings in that they are not considered to have any character encoding nor\ngenerally expected to be printable as human-readable text.\nIn order to print byte sequences as text, additional effort such as Base64 encoding may be required.")]),e._v(" "),a("h4",{attrs:{id:"list-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list-kind"}},[e._v("#")]),e._v(" List kind")]),e._v(" "),a("p",[e._v("List is a recursive kind.")]),e._v(" "),a("p",[e._v("Values contained in lists can be accessed by their ordinal offset in the list.")]),e._v(" "),a("h4",{attrs:{id:"map-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-kind"}},[e._v("#")]),e._v(" Map kind")]),e._v(" "),a("p",[e._v("Map is a recursive kind.")]),e._v(" "),a("p",[e._v('Values in maps are accessed by their "key".  Maps can also be iterated over,\nyielding key+value pairs.')]),e._v(" "),a("h4",{attrs:{id:"link-kind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#link-kind"}},[e._v("#")]),e._v(" Link kind")]),e._v(" "),a("p",[e._v("A link represents a link to another IPLD Block. The link reference\nis a "),a("RouterLink",{attrs:{to:"/data-model-layer/CID.html"}},[a("code",[e._v("CID")])]),e._v(".")],1),e._v(" "),a("p",[e._v('Link is a scalar kind -- however, when "loaded", may become another kind, either scalar or recursive!')]),e._v(" "),a("h3",{attrs:{id:"kinds-implementation-references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kinds-implementation-references"}},[e._v("#")]),e._v(" Kinds Implementation References")]),e._v(" "),a("ul",[a("li",[e._v("Kinds in Go: https://github.com/ipld/go-ipld-prime/blob/master/kind.go")])])])}),[],!1,null,null,null);t.default=s.exports}}]);